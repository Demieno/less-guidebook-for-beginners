# Преобразования и переменные

Чтобы компилятор выполнял хоть сколько-нибудь полезные действия, интерпретируя JavaScript-код — ему нужны значения, которые он может получить из переменных, переданных в примесь.




## Способ 1. Переменные

Самым простым способом получить значения из переменных в Less является следующая функция:

```js
(function(a, b) {
  return a + b;
})('@{a}', '@{b}')
```

Используя обёртку в виде примеси, её можно представить в удобном для использования виде:

```less
.mixin(@a, @b) {
  @js: ~`(function(a, b) { return a + b; })('@{a}', '@{b}')`;

  content: @js;
}

.test-js {
  .mixin(1, 2);
}
```

Результатом компиляции будет являться сумма двух чисел, переданных, как аргументы примеси `.mixin()`:

```css
.test-js {
  content: 12;
}
```




## Способ 2. Массив

Если для проведения операций в выражении требуется большое количество переменных, то на помощь приходит следующая функция, возвращающая массив всех переданных аргументов:

```js
(function(args) {
  return args;
})('@{arguments}')
```

Записывая эту функцию в переменную и используя примесь, у которой на вход подаётся переменное количество аргументов, получим следующий less-код:

```less
.mixin(...) {
  @js: ~`(function(args){ return args; })('@{arguments}')`;

  content: @js;
}

.test-js {
  .mixin(3, 123);
}
```

И, как я уже сказал, после компиляции будет доступен массив всех переданных значений:

```css
.test-js {
  content: [3, 123];
}
```

Однако, далее в Less с таким результатом сделать ничего не получится (квадратные скобки), поэтому на практике лучше всего использовать следующую модификацию предложенной функции:

```js
(function(args) {
  return args;
})((function() {
  var args = '@{arguments}';
  return args.replace(/^\[|\]$/g, '')
})())
```

Эта функция удаляет квадратные скобки, делая получаемый на выходе массив немного лучше:

```less
.mixin(...) {
  @js: ~`function(args){return args}(function(){var args='@{arguments}';return args.replace(/^\[|\]$/g,'')}())`;

  content: @js;
}

.test-js {
  .mixin(3, 123);
}
```

В итоге результатом компиляции вновь будет строка, которая не пригодна для работы в виде списка, но зато показывающая принцип взаимодействия Less и JavaScript:

```css
.test-js {
  content: 3, 123;
}
```




## Преобразование значений

Конечно, на практике мало пользы от того, что вы можете получить, распарсить и отдать результат обратно — необходимо с ним как-то взаимодействовать.

В приведённом ниже примере последнему в списке значению добавляется единица измерения `deg`:

```js
(function(args) {
  return args = args || '0, 0, 0, 0', args = args.replace(/,\s*\d+$/, function(args) {
    return args + 'deg'
  })
})((function() {
  var args = '@{arguments}';
  return args = args.replace(/^\[|\]$/g, '')
})())
```

В итоге примесь имеет вид:

```less
.rotate3d(...) {
  @js: ~`(function(args) { return args = args || '0, 0, 0, 0', args = args.replace(/,\s*\d+$/, function(args) { return args + 'deg' }) })((function() { var args = '@{arguments}'; return args = args.replace(/^\[|\]$/g, '') })())`;

  transform: rotate3d(@js);
}

.test-js {
  .rotate3d(1, 0, 0, 50);
}
```

После компиляции получится отформатированное значение свойства `transform`:

```css
.test-js {
  transform: rotate3d(1, 0, 0, 50deg);
}
```

Если вызвать эту же примесь без аргументов, то будет выводиться результат по умолчанию, то есть нули:

```css
.test-js {
  transform: rotate3d(0, 0, 0, 0deg);
}
```

> Описанные в этой главе примеры доступны под номера 6.1.1 - 6.1.4.




## Выводы и мысли

Да, Less умеет обрабатывать JavaScript-код, записанный в переменной, но получаемая от этого польза слишком мала и не покрывает потраченных на это усилий. В итоге, используя JavaScript в Less вы загрязняете его и усложняете для восприятия.
