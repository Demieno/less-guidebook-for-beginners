# Строки и списки

## Экранирование

Компилятор, сам по себе, штука умная. Но даже у умных штук есть проблемы. Например, компилятор не может сходу определить, является ли предлагаемая ему для обработки конструкция валидной. Проще говоря, если конструкция не предназначается компилятору, то может случиться порождение ошибки. Для предотвращения таких проблемных ситуаций, используется экранирование значения переменных, которое было подробнее рассмотрено в главе 3.




## Функция кодирования (Escape)

Вместо того, чтобы еще раз говорить об экранировании, давайте рассмотрим функцию кодирования символов — `escape`.

Функция `escape`, позволяет закодировать символы, которые могут вызывать проблемы в CSS. Например, такими символами являются: `пробел`, `#`, `^`, `(`, `)`, `;` и т.д.

Зачем это может пригодиться в Less? — одним создателям известно. Конечно, можно предположить, что таким образом можно вставлять текст в значение свойства `content` или что-то в этом духе, но это не работает, так как требуются кавычки, которые эта функция кодирует. Пусть это останется загадкой.

Я честно пытался найти применение этой функции, но ничего не получилось. Поэтому наслаждайтесь замечательным примером из документации:

```less
escape('a=1') // a%3D1
```




## Форматирование строк

Еще одной странной для CSS-препроцессора возможностью является функция форматирования строк, которая позволяет формировать строки, используя некий шаблон.

Например, можно подставлять в строку данные, получаемые из переменных или указав их напрямую:

```less
@string: "В этот замечательный день %a, я хочу сказать вам: %a";
@date: e("(28.06.2015)");
@message: в Less так много странных функций;

.block {
  content: %(@string, @date, @message);
}
```

Компилятор просто подставит строки из переменных в шаблон:

```css
.block {
  content: "В этот замечательный день (28.06.2015), я хочу сказать вам: в Less так много странных функций";
}
```

Пересказывать документацию я не вижу смысла, поэтому подробнее об этой возможности я советую почитать в первоисточнике, так как там есть информация о знаке % и кодировании подставляемых в шаблон строк.




## Функция замены (Replace)

На мой взгляд, это такая же странная функция для CSS-препроцессора, как и функция форматирования строк, которые можно рассматривать как задел на будущее. Сейчас же использование таких возможностей под вопросом, так как мало кому нужно форматировать строки, используя CSS-препроцессор, учитывая, что все это потом превратится в CSS, где строки нужны лишь в свойстве content.

```less
.block {
  content: replace("Less имеет много нужных функций", "нужных", "странных");
}
```

В приведенном выше примере, слово «нужных» будет заменено на слово «странных», что в итоге даст довольно правдивую строку:

```css
.block {
  content: "Less имеет много странных функций";
}
```

Давайте перейдем к более полезным возможностям препроцессора Less — работе со списками (почти массивами).




## Списки

Наиболее интересной возможностью Less, из описанных в этой части, является работа со списками, которые в мире программирования называются массивами.

Списки в Less выглядят следующим образом:

```less
@list: "one", two, three four;
```

В приведенном мной примере, список состоит из трех элементов: "one", two и three four.

Препроцессор Less не обязывает вас использовать запятые, то есть список может выглядеть следующим образом:

```less
@list: "one" two three four;
```

Кавычки считаются вместе с элементом, вокруг которого они поставлены. Они также не обязательны, поэтому их можно опустить, если элемент не состоит из двух и более слов.

Для того, чтобы достать из списка какой-либо элемент, используется функция `extract`. Важно запомнить, что нумерация здесь начинается не с 0, как это принято, а с 1.

Допустим, что у нас есть частичный список глав этой книги и нам нужно достать значение текущей главы. Решается эта задача очень просто:

```less
@list: "Основы", "Работа с селекторами, медиа-запросами и файлами", "Переменные и примеси", "Операции со свойствами и встроенные функции";
```

Для разнообразия применим возможность форматирования текста, описанную выше:

```less
.block {
  @currentStatus: e(extract(@list, 4));
  content: %("Текущая глава: %a", @currentStatus);
}
```

```css
.block {
  content: "Текущая глава: Операции со свойствами и встроенные функции";
}
```

> Напомню, что обычно функция `e()` применяется для экранирования. Однако, здесь она применяется лишь для того, чтобы избавиться от кавычек, которые являются частью элемента списка.

Помимо функции `extract()`, иногда применяется функция для определения длины списка — `length()`. Применим ее к списку глав:

```less
.block {
  content: length(@list);
}
```

Попробуйте догадаться, что выведет компилятор. Ну конечно же! Четыре:

```css
.block {
  content: 4;
}
```

К сожалению, аналогов других методов, принятых в JavaScript в Less нет.


#### Пример 4.2.1

Теперь давайте поработаем со списком в более серьезном ключе. Допустим, что у нас есть список префиксов для селекторов сетки (xs, sm, md, lg) и нам нужно добавить их при построении сетки.

К сожалению, данный пример нельзя продемонстрировать без применения цикла, поэтому сейчас будет немного слегка не очевидной магии. Просто знайте, что на **каждой итерации цикла** в селектор будет подставляться **значение из списка**. Более подробно о циклах смотрите в главе 5.

```less
@column-name: col;
@column-count: 4;
@column-prefix: xs, sm, md, lg;

// Генератор селекторов
.generate-class(@indexCount, @indexPrefix: 1) when (@indexPrefix =< length(@column-prefix)) {

  // Получаем элемент списка
  @prefix: extract(@column-prefix, @indexPrefix);

  // Формируем селектор
  .@{column-name}-@{prefix}-@{indexCount} {
    width: @indexCount * (100% / @column-count);
  }

  // Порождаем следующую итерацию
  .generate-class(@indexCount, @indexPrefix + 1);
}

// Генератор сетки
.make-grid(@indexCount: 1) when (@indexCount =< @column-count) {

  // Вызываем генератор селекторов
  .generate-class(@indexCount);

  // Порождаем следующую итерацию
  .make-grid(@indexCount + 1);

}

// Вызываем генератор сетки
.make-grid();
```

Кстати, в скомпилированном виде это выглядит так:

```css
.col-xs-1 { width: 25%; }
.col-sm-1 { width: 25%; }
.col-md-1 { width: 25%; }
.col-lg-1 { width: 25%; }

/*
 * ...
 * Здесь еще восемь классов, которые я убрал ради экономии места
 * ...
 */

.col-xs-4 { width: 100%; }
.col-sm-4 { width: 100%; }
.col-md-4 { width: 100%; }
.col-lg-4 { width: 100%; }
```

Поздравляю с боевым крещением, так как циклы — это самое сложное, что есть в Less. Но не волнуйтесь — мы с ними еще встретимся в следующей главе, где будем говорить о них намного подробнее.
