# Условные конструкции (защита примесей)

Для того, чтобы контролировать вывод CSS-кода в зависимости от наличия конкретных значений или выполнении определенных условий при компиляции, можно использовать условные конструкции.

Обычно, в языках программирования различают три вида условных конструкций по количеству ветвей (возможных исходов):

 * с одной ветвью
 * с двумя ветвями
 * с несколькими ветвями

Соответственно, если условная конструкция имеет одну ветвь, то исход может быть либо `true` и код внутри блока будет выполняться, либо `false` и код внутри блока будет игнорироваться:

```js
if (условие) {
  return true;
}
```

Если конструкция имеет две ветви развития ситуации, то она выглядит следующим образом:

```js
if (условие) {
  return true;
} else {
  return false;
}
```

При любом исходе (true или false) условного выражения будет выполнен соответствующий исходу код.

Также различают многоветвевые условные конструкции:

```js
if (...) {
  ...
} else if (...) {
  ...
} else {
  ...
}
```

Различают также тернарный оператор, который позволяет присваивать переменным разные значения в зависимости от логического выражения. В JavaScript он имеет вид:

```js
var max = (num1 > num2) ? num1 : num2;
```




## Ситуация в Less

Условная конструкция — это самая часто используемая почти во всех языках программирования инструкция, к сожалению, отсутствующая в явном виде в Less.

В Less введены условные конструкции только с одной ветвью, но в странном для программистов виде:

```less
when (условие) {
  команда для true
}
```

> **Замечание**
>
> Тернарного оператора в Less нет.

Используются условные конструкции для *защиты примесей*, то есть их выполнении при определенном стечении обстоятельств. В нашем случае обстоятельствами могут быть лишь переменные и их значения.

Конструкция `when` имеет лишь один положительный финал. Банальный `else` здесь написать просто так не получится. Забегая вперед скажу, что это возможно, но синтаксис не сможет вас порадовать.



### Операторы отношений

Операторы отношений: «меньше» (`<`), «больше» (`>`), «меньше или равно» (`=<` или `<=`),«больше или равно» (`>=`) и «равно» (`=`) сравнивают значения также, как и в JavaScript. Каждый из них возвращает логическое значение.

> **Замечание**
>
> Оператор отношения «меньше или равно» (`=<` или `<=`) отличается от аналогичного в JavaScript, где его запись имеет только один вид (`<=`). В соответствии с документацией принято использовать (`=<`).



### Логическое НЕ, И и ИЛИ

Условия могут содержать ключевое слово `not`, являющееся аналогом привычного нам по JavaScipt отрицания `!`.

Например, следующая примесь будет выполняться, если переданное ей значение `@value` не равно нулю.

```less
.mixin(@value) when not (@value = 0) {
  color: #777;
}
```

Также условия можно объединять, создавая более конкретные условия. Для этого используется ключевое слово `and`.

```less
.mixin(@value) when (@value > 0) and (@value =< 100) {
  color: #777;
}
```

Ключевое слово `and` можно опускать, используя взамен запятую:

```less
.mixin(@value) when (@value > 0), (@value =< 100) {
  color: #777;
}
```

Ключевое слово `or` соответствует логическому ИЛИ. Однако, к сожалению, эта возможность не включена в компилятор, хотя в исходном коде присутствует.

Помимо написанных вручную условий, можно использовать некоторые встроенные функции для проверки величин на совпадение с различными типами и размерностями. Но об этом позднее.



### Работа с типами данных

В главе 4 были рассмотрены функции для определения типа данных, которыми оперирует пользователь препроцессора Less. Все эти функции можно использовать в условном операторе. Причем важно отметить, что Less автоматически преобразует результат выражения в логическое значение, как это делает JavaScript, вызывая для него функцию `Boolean()`.

Так, например, расмотренная ранее функция `isnumber()`, проверяющая являются ли предоставленные ей данные числом, может применяться следующим образом:

```less
.return-number(@number) when (isnumber(@number)) {
  content: @number;
}

.true {
  .return-number(123);
}

.false {
  .return-number("123");
}
```

В первом случае будет создан селектор `.true`, так как передаваемое значение в примесь является числом. Во втором же случае, передаваемое значение — строка, что означает `false`.



#### Пример 4.1.1

Для лучшего понимания происходящего разберем конкретный пример примеси, которая генерирует свойство для установления эффекта перехода между двумя состояниями элемента.

```less
.transition(@property: all, @function: ease, @duration: .3s, @delay: 0) {
  transition: @property @duration @function @delay;
}
```

Здесь объявлена обычная примесь с несколькими аргументами и их значениями по умолчанию. Однако, это мало нас интересует — куда интереснее взглянуть на то, что находится внутри.

Внутри мы отчетливо видим свойство `transition`, значение которого собирается из переданных параметров. Но что делать, если в каком-то контексте нам не нужна задержка (delay)?

Правильно, использовать условный оператор.

Преобразуем нашу примесь таким образом, чтобы по умолчанию свойство собиралось с задержкой равной нулю. Если же переданное в примесь значение переменной `@delay` не равняется нулю, то пусть используется полное свойство.

```less
.transition(@property: all, @function: ease, @duration: .3s, @delay: 0) {
  transition: @property @duration @function 0;

  & when not (@delay = 0) {
    transition: @property @duration @function @delay;
  }
}
```

В этой примеси после ссылки на родителя селектора, используется условное выражение, проверяющее значение переменной `@delay` на отличие от нуля.

Немного не очевидным способом применения условных конструкций на практике является создание циклов. Именно о них сейчас и пойдет речь.
